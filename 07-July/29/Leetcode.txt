2411. Smallest Subarrays With Maximum Bitwise OR
_________________________________________________________

class Solution{
    public int[] smallestSubarrays(int[] nums){
        int n = nums.length;
        int[] result = new int[n];

        int[] latest = new int[32];
        Arrays.fill(latest, -1);

        for (int i = n - 1; i >= 0; i--){
            int farthest = i; 

            for (int b = 0; b < 32; b++){
                if (((nums[i] >> b) & 1) != 0){
                    latest[b] = i;
                }

                if (latest[b] != -1){
                    farthest = Math.max(farthest, latest[b]);
                }
            }

            result[i] = farthest - i + 1;
        }

        return result;
    }
}
_________________________________________________________




Problem Statement :
You are given a 0-indexed array nums of length n, consisting of non-negative integers. For each index i from 0 to n - 1, you must determine the size of the minimum sized non-empty subarray of nums starting at i (inclusive) that has the maximum possible bitwise OR.

In other words, let Bij be the bitwise OR of the subarray nums[i...j]. You need to find the smallest subarray starting at i, such that bitwise OR of this subarray is equal to max(Bik) where i <= k <= n - 1.
The bitwise OR of an array is the bitwise OR of all the numbers in it.

Return an integer array answer of size n where answer[i] is the length of the minimum sized subarray starting at i with maximum bitwise OR.

A subarray is a contiguous non-empty sequence of elements within an array.







Approach : 
Initialize:
latest[32] to -1 (to track last seen index of each bit).
result[n] for storing subarray lengths.

Traverse Right to Left:
For each index i from n-1 to 0:
For each bit b (0 to 31):
If bit b is set in nums[i], update latest[b] = i.
Track the farthest index among all latest[b] â‰  -1.

Compute Length:
result[i] = farthest - i + 1.

Return result.






Complexity : 
Time Complexity : O(n)
Space Complexity : O(n)