Longest Subarray with Majority Greater than K
_______________________________________________________

class Solution {
    public int longestSubarray(int[] arr, int k) {
        int sum = 0;
        int res = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i=0 ; i<arr.length ; i++){
            if(arr[i]>k) arr[i]=1;
            else arr[i]=-1;
        }
        for(int i=0 ; i<arr.length ; i++){
            sum += arr[i];
            if(sum>0) res = Math.max(res,i+1);
            if(map.containsKey(sum-1)){
                res = Math.max(i-map.get(sum-1),res);
            }
            if(!map.containsKey(sum)){
                map.put(sum,i);
            }
        }
        return res;
    }
}
_______________________________________________________





Problem Statement :
Given an array arr[] and an integer k, the task is to find the length of longest subarray in which the count of elements greater than k is more than the count of elements less than or equal to k.





Approach :
Step 1: Transform the array
Convert the array into 1s and -1s:
If arr[i] > k → replace with 1 (favorable element)
If arr[i] <= k → replace with -1 (unfavorable element)
This transformation turns the problem into:
Find the longest subarray with a positive sum.

Step 2: Use prefix sum + hashmap
Initialize sum = 0, res = 0
Create a hashmap map to store first occurrence of each prefix sum value

Traverse the array and maintain a prefix sum (sum):
If sum > 0, then the subarray from 0 to i has more 1s than -1s → update res = i + 1
If sum - 1 has been seen before at index j, then the subarray from j+1 to i has a net sum of +1 or more → update res = max(res, i - j)
Only store the first occurrence of each sum value in the map (to maximize the subarray length)

return the res





Complexity : 
Time Complexity: O(n)
Space Complexity: O(n)