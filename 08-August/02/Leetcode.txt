2561. Rearranging Fruits
________________________________________________________

class Solution {
    public long minCost(int[] b1, int[] b2) {
        Map<Integer, Integer> m1 = new HashMap<>(), m2 = new HashMap<>();
        for (int x : b1) m1.put(x, m1.getOrDefault(x, 0) + 1);
        for (int x : b2) m2.put(x, m2.getOrDefault(x, 0) + 1);
        
        Set<Integer> all = new HashSet<>(m1.keySet());
        all.addAll(m2.keySet());
        
        int min = Integer.MAX_VALUE;
        List<Integer> l1 = new ArrayList<>(), l2 = new ArrayList<>();
        
        for (int x : all) {
            min = Math.min(min, x);
            int d = m1.getOrDefault(x, 0) - m2.getOrDefault(x, 0);
            if (d % 2 != 0) return -1;
            if (d > 0) for (int i = 0; i < d/2; i++) l1.add(x);
            else if (d < 0) for (int i = 0; i < -d/2; i++) l2.add(x);
        }
        
        Collections.sort(l1);
        Collections.sort(l2, Collections.reverseOrder());
        
        long res = 0;
        for (int i = 0; i < l1.size(); i++) 
            res += Math.min((long)Math.min(l1.get(i), l2.get(i)), 2L * min);
        
        return res;
    }
}
________________________________________________________



Problem Statement :
You have two fruit baskets containing n fruits each. You are given two 0-indexed integer arrays basket1 and basket2 representing the cost of fruit in each basket. You want to make both baskets equal. To do so, you can use the following operation as many times as you want:

Chose two indices i and j, and swap the ith fruit of basket1 with the jth fruit of basket2.
The cost of the swap is min(basket1[i],basket2[j]).
Two baskets are considered equal if sorting them according to the fruit cost makes them exactly the same baskets.

Return the minimum cost to make both the baskets equal or -1 if impossible.





Approach :
Count the Fruits: Use HashMaps to count the quantity of each fruit in each basket. 

Find the Cheapest Fruit: Identify the fruit with the lowest "cost". 

Identify the Imbalance: Determine which fruits need to be moved from which basket to balance things out. Create two lists: fruits to move from basket 1 to basket 2, and vice versa. 

Sort the Movement Lists: Sort the lists to optimize the swapping strategy (expensive fruits with cheap ones). 

Calculate the Minimum Cost: Iterate through the lists, calculating the cost of each swap, and summing them up. Use the cheapest fruit to make swaps cheaper! 

Return the Total Cost: Give back the minimum possible cost to balance the baskets. 






Complexity : 
Time Complexity : O(n * logn)
Space Complexity : O(n)