Minimum days to make M bouquets
______________________________________________________

class Solution {
    public int minDaysBloom(int[] arr, int k, int m) {
        int n = arr.length;
        if ((long)m * k > n) return -1; // Not enough flowers

        int low = Integer.MAX_VALUE, high = Integer.MIN_VALUE;
        for (int val : arr) {
            low = Math.min(low, val);
            high = Math.max(high, val);
        }

        int ans = -1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (canMake(arr, mid, k, m)) {
                ans = mid;
                high = mid - 1; // try smaller day
            } else {
                low = mid + 1;
            }
        }
        return ans;
    }

    private boolean canMake(int[] arr, int day, int k, int m) {
        int bouquets = 0, consecutive = 0;
        for (int val : arr) {
            if (val <= day) {
                consecutive++;
                if (consecutive == k) {
                    bouquets++;
                    consecutive = 0; // reset since flower can’t be reused
                }
            } else {
                consecutive = 0;
            }
        }
        return bouquets >= m;
    }
}

______________________________________________________




Problem Statement : 
You have a row of flowers, where each flower blooms after a specific day. The array arr[] represents the blooming schedule: arr[i] is the day the flower at position i will bloom. To create a bouquet, you need to collect k adjacent bloomed flowers. Each flower can only be used in one bouquet.

Your goal is to find the minimum number of days required to make exactly m bouquets. If it is not possible to make m bouquets with the given arrangement, return -1.





Approach : 
Check feasibility:
If m * k > n (total flowers), return -1.

Binary search range:
low = min(arr), high = max(arr) (possible days).

Binary search on days:
While low <= high:
mid = (low + high) / 2
Check if we can make m bouquets by day mid using helper.

Helper function (canMake):
Traverse arr, count consecutive bloomed flowers (arr[i] <= mid).
Each time consecutive == k, form 1 bouquet and reset consecutive.
If total bouquets ≥ m, return true.

Update search:
If true, record mid and search left (high = mid - 1).
Else, search right (low = mid + 1).

Return answer.





Complexity : 
Time Complexity : O(n * log(max(arr)))
Space Complexity : O(1)