Farthest Smaller Right
______________________________________________________

import java.util.*;

class Solution {
    public ArrayList<Integer> farMin(int[] arr) {
        int n = arr.length;
        int[] suf = new int[n];
        suf[n - 1] = arr[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            int v = arr[i];
            int prev = suf[i + 1];
            suf[i] = v < prev ? v : prev;
        }

        int[] ans = new int[n];
        Arrays.fill(ans, -1);

        for (int i = 0; i < n - 1; i++) {
            int a = arr[i];

            // quick rejects / accepts to avoid binary search
            if (suf[i + 1] >= a) continue;         // no smaller to the right
            if (suf[n - 1] < a) {                   // last element itself is smaller
                ans[i] = n - 1;
                continue;
            }

            // binary search last index p in [i+1..n-1] where suf[p] < a
            int l = i + 1, r = n - 1, best = -1;
            while (l <= r) {
                int mid = (l + r) >>> 1;
                if (suf[mid] < a) {
                    best = mid;      // try farther right
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
            ans[i] = best; // best is guaranteed >= i+1 here
        }

        ArrayList<Integer> out = new ArrayList<>(n);
        for (int v : ans) out.add(v);
        return out;
    }
}

______________________________________________________


Problem Statement :
You are given an array arr[]. For each element at index i (0-based indexing), find the farthest index j to the right (i.e., j > i) such that arr[j] < arr[i]. If no such index exists for a given position, return -1 for that index. Return the resulting array of answers.






Approach : 
Coordinate-compress array values to ranks 1..m.

Use a BIT that stores the maximum (index+1) seen for each rank.

Iterate i from n-1 down to 0:
Query BIT for prefix (rank(arr[i]) - 1) to get the largest index j+1 where arr[j] < arr[i].
If query result is 0 → no smaller → answer -1, else answer query-1.
Update BIT at rank(arr[i]) with i+1.

Return results.





Complexity : 
Time Complexity : O(n log n)
Space Complexity : O(n)