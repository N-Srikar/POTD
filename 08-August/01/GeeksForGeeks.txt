Balancing Consonants and Vowels Ratio
________________________________________________________

class Solution {
    public int countBalanced(String[] arr) {
        HashMap<Integer,Integer> map = new HashMap<>();
        int sum = 0;
        int count = 0;
        map.put(sum,1);
        for(int idx=0 ; idx<arr.length ; idx++){
            String str = arr[idx];
            for(int i=0 ; i<str.length() ; i++){
                char ch = str.charAt(i);
                if(isVowel(ch)){
                    sum++;
                }
                else{
                    sum--;
                }
            }
            if(sum==0){
                count+= map.get(sum);
                map.put(sum,map.get(sum)+1);
            }
            else if(map.containsKey(sum)){
                count += map.get(sum);
                map.put(sum,map.get(sum)+1);
            }
            else{
                map.put(sum,1);
            }
        }
        return count;
    }
    public static boolean isVowel(char ch){
        return (ch=='a' || ch=='e' || ch=='i' || ch=='o' || ch=='u');
    }
}
________________________________________________________




Problem Statement :
You are given an array of strings arr[], where each arr[i] consists of lowercase english alphabets. You need to find the number of balanced strings in arr[] which can be formed by concatinating one or more contiguous strings of arr[].
A balanced string contains the equal number of vowels and consonants. 





Approach : 
Initialize:
sum = 0: Keeps track of net vowel-consonant difference.
map: Stores frequency of each sum seen so far.
count = 0: Total number of balanced substrings found.

Iterate over each string in arr:
For each character:
If vowel → sum++
If consonant → sum--

After processing each string:
If sum seen before in map, 
then all previous prefixes with the same sum can form a balanced substring ending here → count += map.get(sum)
Update frequency of sum in map.

Return count : total number of balanced concatenations.






Complexity : 
Time Complexity : O(n * m)
Space Complexity : O(n * m)